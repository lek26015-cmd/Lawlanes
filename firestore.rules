
/**
 * @fileOverview Firestore Security Rules for Lawlanes application.
 *
 * Core Philosophy:
 * This ruleset prioritizes secure access to lawyer profiles and chat functionality.
 * - Lawyer Profiles: Only approved profiles are public, with write access restricted to owners.
 * - Chats: Chat rooms and messages are private, accessible only to the participants involved.
 *
 * Data Structure:
 * - /lawyerProfiles/{lawyerProfileId}: Contains public lawyer data.
 * - /chats/{chatId}: Contains chat session metadata, including an array of participant UIDs.
 * - /chats/{chatId}/messages/{messageId}: Contains individual chat messages.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Helper functions to improve readability and code reuse.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Grants read access to approved lawyer profiles and write access to owners.
     * @path /lawyerProfiles/{lawyerProfileId}
     */
    match /lawyerProfiles/{lawyerProfileId} {
      allow get, list: if true; // Allow public read access for all profiles. Filtering by 'approved' status is done client-side.
      allow create: if isOwner(request.resource.data.userId);
      allow update, delete: if isOwner(resource.data.userId);
    }

    /**
     * @description Secures chat rooms. Access is restricted to participants of the chat.
     * @path /chats/{chatId}
     */
    match /chats/{chatId} {
      function isParticipant() {
        return isSignedIn() && request.auth.uid in resource.data.participants;
      }
      
      // Allow a user to see if a chat room exists if they are a participant.
      // This is needed for the client to check for existing chats.
      allow get: if isParticipant();

      // IMPORTANT: A broad `list` is not secure here.
      // Client queries MUST be secured with `where('participants', 'array-contains', request.auth.uid)`.
      // This rule allows that specific query.
      allow list: if isSignedIn();

      // Allow a signed-in user to create a new chat room,
      // but they MUST include their own UID in the participants list.
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participants;

      // Only participants can update chat metadata (e.g., last message timestamp - though not implemented yet).
      allow update: if isParticipant();

      /**
       * @description Secures messages within a chat room.
       * @path /chats/{chatId}/messages/{messageId}
       */
      match /messages/{messageId} {
        // Function to check if the requester is part of the parent chat document.
        function isChatParticipant() {
          return exists(/databases/$(database)/documents/chats/$(chatId)) &&
                 request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        }

        // Allow reading a single message if the user is a participant.
        allow get: if isSignedIn() && isChatParticipant();
        
        // Allow LIST operation only if the user is signed in and is a participant.
        // The parent /chats/{chatId} `get` rule already ensures the user is a participant of that chat
        // when the client constructs the query, so this is an extra layer of defense.
        allow list: if isSignedIn() && isChatParticipant();

        // Allow a participant to create a new message, ensuring the senderId is their own.
        allow create: if isSignedIn() && 
                       request.resource.data.senderId == request.auth.uid &&
                       isChatParticipant();
        
        // Generally, messages are immutable.
        allow update, delete: if false;
      }
    }
  }
}
